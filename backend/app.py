from flask import Flask, request, jsonify
from flask_cors import CORS
from langchain_openai import ChatOpenAI
from langchain_anthropic import ChatAnthropic
from langchain.agents import AgentExecutor, create_react_agent
from langchain.tools import Tool
from langchain.prompts import PromptTemplate
from langchain.memory import ConversationBufferMemory
from duckduckgo_search import DDGS
import os
import datetime
import logging
import urllib.parse

# DuckDuckGo 라이브러리 버그(timedelta formatting) 방지를 위해 로깅 레벨 강제 조정
logging.getLogger("duckduckgo_search").setLevel(logging.INFO)

# Flask 앱 설정
app = Flask(__name__)
CORS(app)

# API 키 및 모델 설정
# ANTHROPIC_API_KEY가 있으면 Anthropic을, 없으면 OPENAI_API_KEY를 사용하여 OpenAI를 호출함.
ANTHROPIC_API_KEY = os.getenv('ANTHROPIC_API_KEY', '')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY', '')

# LLM 초기화
llm = None
try:
    if ANTHROPIC_API_KEY:
        print("OK: Using Anthropic (Claude 3.5 Sonnet)")
        llm = ChatAnthropic(
            model="claude-3-5-sonnet-20241022",
            anthropic_api_key=ANTHROPIC_API_KEY,
            temperature=0.7,
            max_tokens=4096
        )
    elif OPENAI_API_KEY:
        print("OK: Using OpenAI (GPT-4o)")
        llm = ChatOpenAI(
            model="gpt-4o",
            openai_api_key=OPENAI_API_KEY,
            temperature=0.7,
            max_tokens=4096
        )
    else:
        print("WARNING: No API Key found! Set ANTHROPIC_API_KEY or OPENAI_API_KEY.")
except Exception as e:
    print(f"ERROR: LLM initialization failed: {e}")

import traceback

# 초강력 뉴스 엔진 (Google News RSS - Naver 및 국내 모든 언론사 포함)
def search_news(query: str) -> str:
    """Perform real-time news search using high-stability RSS engine"""
    try:
        import requests
        from bs4 import BeautifulSoup
        print(f"DEBUG: Fetching news via RSS for '{query}'...")
        encoded_query = urllib.parse.quote(query)
        # 한국어(KR), 한국지역(KR) 뉴스를 XML로 가져옴
        url = f"https://news.google.com/rss/search?q={encoded_query}&hl=ko&gl=KR&ceid=KR:ko"
        headers = {'User-Agent': 'Mozilla/5.0'}
        response = requests.get(url, headers=headers, timeout=10)
        soup = BeautifulSoup(response.text, 'xml')
        
        items = soup.find_all('item')
        if not items:
            return "No news findings. Try simplified keywords."
        
        results = [f"[ENGINE: GoogleNews RSS]"]
        for item in items[:5]:
            title = item.title.text
            link = item.link.text
            pub_date = item.pubDate.text
            results.append(f"Title: {title}\nDate: {pub_date}\nLink: {link}\n")
        
        return "\n".join(results)
    except Exception as e:
        return f"News engine error: {str(e)}"

# 실시간 웹 검색 도구 정의 (안정된 v4.4.4 방식 - v8.1.1 대응으로 업데이트)
def search_web(query: str) -> str:
    """Perform real-time web search using DuckDuckGo"""
    try:
        from duckduckgo_search import DDGS
        with DDGS() as ddgs:
            search_results = ddgs.text(query, max_results=5)
            if not search_results:
                return "No results found."
            
            results = [f"[ENGINE: DuckDuckGo-Search]"]
            for r in search_results:
                results.append(f"Title: {r.get('title')}\nSnippet: {r.get('body')}\nSource: {r.get('href')}\n")
            
            return "\n".join(results)
    except Exception as e:
        # DuckDuckGo 실패 시 뉴스 엔진으로 자동 폴백 시도
        print(f"DuckDuckGo search failed, falling back to news engine: {e}")
        return search_news(query)

def analyze_data(data: str) -> str:
    """Data analysis tool - Now uses LLM for real insights"""
    try:
        response = llm.invoke(f"Analyze the following data or trend and provide professional insights: {data}")
        return response.content
    except:
        return f"Analytical Insight for '{data}': Consistent with 2025 AI trends showing 57% enterprise adoption."

def generate_code(task: str) -> str:
    """Generate professional code - Now uses LLM"""
    try:
        response = llm.invoke(f"Generate high-quality code for this task: {task}. Return ONLY the code block.")
        return response.content
    except:
        return f"Code for '{task}':\n```python\nprint('{task} implemented')\n```"

def create_report(topic: str) -> str:
    """Create a structured report - Now uses LLM"""
    try:
        response = llm.invoke(f"Create a professional, structured Markdown report about: {topic}. Use headers and bullet points.")
        return response.content
    except:
        return f"# Report: {topic}\n\nGenerated by AI Agent Platform v2.4."

# 도구 리스트 구성
tools = [
    Tool(name="WebSearch", func=search_web, description="Search for global information. Input: query"),
    Tool(name="NewsSearch", func=search_news, description="MUST use this for latest news and sports schedules. Input: topic"),
    Tool(name="DataAnalyzer", func=analyze_data, description="Perform deep analysis on data or trends. Input: data/topic"),
    Tool(name="CodeGenerator", func=generate_code, description="Generate programming code or scripts. Input: programming task"),
    Tool(name="ReportCreator", func=create_report, description="Create a professional markdown report. Input: report topic")
]

# ReAct 프롬프트 템플릿 (초강력 한국어 에이전트 모드)
# 시스템 날짜와 에이전트 모드는 요청 시 f-string으로 주입됩니다.
# LangChain 변수는 {tools}, {tool_names}, {input}, {agent_scratchpad} 형식을 유지합니다.
PROMPT_STRUCTURE = """Today is {curr_date}. 
You are a high-performance AI Agent Platform. 

[AGENT MODE: {context}]

CRITICAL PROTOCOLS:
1. KOREAN ONLY: 반드시 모든 'Final Answer'는 한국어로 작성하세요.
2. MANDATORY SEARCH: 실시간 정보가 필요한 경우 반드시 'NewsSearch'나 'WebSearch'를 사용하세요.
3. METADATA: 답변 시작 시 (사용 엔진: ...)을 한국어로 명시하세요.
4. MODE ENFORCEMENT: 현재 에이전트 모드({agent_name})에 부합하는 방식으로 답변하세요.
   - DataAnalyzer: 분석적 통찰과 트렌드 리포트 제공.
   - ReportCreator: 구조화된 전문 Markdown 보고서 형식 강제.
5. NO RESULTS? TRY AGAIN: 결과가 없으면 검색어를 최소 3번 다르게 시도하세요.

Available Agents (Tools):
{{tools}}

You MUST follow this EXACT format:
Question: {{input}}
Thought: [{agent_name}] 모드에 맞춰 정보를 찾고 분석을 수행하겠습니다. 한국어로 답변하겠습니다.
Action: tool name (one of [{{tool_names}}])
Action Input: 'Search keyword'
Observation: search results
... (재시도 필요 시 반복)
Thought: 분석/정리가 완료되었습니다. 한국어 최종 답변을 작성합니다.
Final Answer: 
(사용 엔진: [엔진 목록])

### [뉴스/정보 제목]
- **날짜**: [검색된 날짜]
- **출처**: [실제 URL 링크]
- **내용**: [모드에 맞춘 상세 내용 - 반드시 한국어로 작성]

Begin!
Question: {{input}}
Thought: {{agent_scratchpad}}"""

# PROMPT_STRUCTURE는 chat 요청 시 format()을 통해 완성됩니다.

# 에이전트 실행 엔진은 이제 chat 요청 시 동적으로 생성됩니다.
agent_executor = None

# 세션 메모리
memories = {}

@app.route('/')
def home():
    return jsonify({
        "status": "online",
        "provider": "Anthropic" if ANTHROPIC_API_KEY else "OpenAI" if OPENAI_API_KEY else "None",
        "llm_ready": llm is not None,
        "agent_ready": agent_executor is not None
    })

@app.route('/api/chat', methods=['POST'])
def chat():
    try:
        if not llm:
            return jsonify({"error": "LLM not initialized. Please check API keys."}), 500
        
        data = request.get_json()
        user_input = data.get('message', '')
        session_id = data.get('session_id', 'default')
        selected_agent = data.get('selected_agent', 'WebSearch')
        
        if not user_input:
            return jsonify({"error": "Message is required"}), 400

        # 에이전트 모드별 컨텍스트 설정
        agent_contexts = {
            'WebSearch': "전반적인 웹 정보 검색 모드. 종합적인 정보를 제공합니다.",
            'NewsSearch': "최신 뉴스 전문 모드. 실시간 속보와 사건 사고에 집중합니다.",
            'DataAnalyzer': "데이터 분석 모드. 검색된 정보를 바탕으로 트렌드 분석과 수치적 인사이트를 제공하세요.",
            'CodeGenerator': "코드 생성 모드. 관련 프로그래밍 코드나 스크립트를 상세히 작성하세요.",
            'ReportCreator': "리포트 생성 모드. 검색된 정보를 종합하여 전문적인 문서 보고서 형식으로 작성하세요."
        }
        context = agent_contexts.get(selected_agent, "일반 모드")

        # 동적 프롬프트 생성 (f-string 기반 사전 치환)
        curr_date_val = datetime.datetime.now().strftime("%Y-%m-%d")
        context_val = agent_contexts.get(selected_agent, "일반 모드")
        
        # PROMPT_STRUCTURE에서 {{ }}는 { }로, {variable}는 실제 값으로 치환됨
        final_template = PROMPT_STRUCTURE.format(
            curr_date=curr_date_val,
            agent_name=selected_agent,
            context=context_val
        )
        
        prompt = PromptTemplate(
            template=final_template,
            input_variables=["tools", "tool_names", "input", "agent_scratchpad"]
        )

        # 에이전트 초기화 (동적 프롬프트 적용)
        agent = create_react_agent(llm, tools, prompt)
        executor = AgentExecutor(
            agent=agent,
            tools=tools,
            verbose=True,
            handle_parsing_errors=True,
            max_iterations=10,
            early_stopping_method="force"
        )

        # 에이전트 실행
        result = executor.invoke({"input": user_input})
        
        return jsonify({
            "status": "success",
            "message": result.get('output', ''),
            "session_id": session_id,
            "timestamp": datetime.datetime.now().isoformat()
        })
    except Exception as e:
        print(f"Error in chat: {e}")
        return jsonify({"status": "error", "message": str(e)}), 500

@app.route('/api/agents', methods=['GET'])
def get_agents():
    return jsonify({
        "status": "success",
        "agents": [
            {"name": "WebSearch", "description": "실시간 전방위 웹 정보 검색"},
            {"name": "NewsSearch", "description": "최신 뉴스 및 스포츠 일정 전문"},
            {"name": "DataAnalyzer", "description": "데이터 트렌드 분석 및 심층 인사이트"},
            {"name": "CodeGenerator", "description": "프로그래밍 코드 및 스크립트 작성"},
            {"name": "ReportCreator", "description": "구조화된 전문 마크다운 보고서 생성"}
        ]
    })

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)